-- TODO: Handle * url pattern
require "C.stdio"

require "os"
require "io"

require ".libs.socket"
require ".libs.unistd"

local mime_types: hashmap(string, string)
mime_types["aac"] = "audio/aac"
mime_types["abw"] = "application/x-abiword"
mime_types["apng"] = "image/apng"
mime_types["arc"] = "application/x-freearc"
mime_types["avif"] = "image/avif"
mime_types["avi"] = "video/x-msvideo"
mime_types["azw"] = "application/vnd.amazon.ebook"
mime_types["bin"] = "application/octet-stream"
mime_types["bmp"] = "image/bmp"
mime_types["bz"] = "application/x-bzip"
mime_types["bz2"] = "application/x-bzip2"
mime_types["cda"] = "application/x-cdf"
mime_types["csh"] = "application/x-csh"
mime_types["css"] = "text/css"
mime_types["csv"] = "text/csv"
mime_types["doc"] = "application/msword"
mime_types["docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
mime_types["eot"] = "application/vnd.ms-fontobject"
mime_types["epub"] = "application/epub+zip"
mime_types["gz"] = "application/gzip"
mime_types["gif"] = "image/gif"
mime_types["htm"] = "text/html"
mime_types["html"] = "text/html"
mime_types["ico"] = "image/vnd.microsoft.icon"
mime_types["ics"] = "text/calendar"
mime_types["jar"] = "application/java-archive"
mime_types["jpeg"] = "image/jpeg"
mime_types["jpg"] = "image/jpeg"
mime_types["js"] = "text/javascript"
mime_types["json"] = "application/json"
mime_types["jsonld"] = "application/ld+json"
mime_types["mid"] = "audio/midi"
mime_types["midi"] = "audio/x-midi"
mime_types["mjs"] = "text/javascript"
mime_types["mp3"] = "audio/mpeg"
mime_types["mp4"] = "video/mp4"
mime_types["mpeg"] = "video/mpeg"
mime_types["mpkg"] = "application/vnd.apple.installer+xml"
mime_types["odp"] = "application/vnd.oasis.opendocument.presentation"
mime_types["ods"] = "application/vnd.oasis.opendocument.spreadsheet"
mime_types["odt"] = "application/vnd.oasis.opendocument.text"
mime_types["oga"] = "audio/ogg"
mime_types["ogv"] = "video/ogg"
mime_types["ogx"] = "application/ogg"
mime_types["opus"] = "audio/ogg"
mime_types["otf"] = "font/otf"
mime_types["png"] = "image/png"
mime_types["pdf"] = "application/pdf"
mime_types["php"] = "application/x-httpd-php"
mime_types["ppt"] = "application/vnd.ms-powerpoint"
mime_types["pptx"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation"
mime_types["rar"] = "application/vnd.rar"
mime_types["rtf"] = "application/rtf"
mime_types["sh"] = "application/x-sh"
mime_types["svg"] = "image/svg+xml"
mime_types["tar"] = "application/x-tar"
mime_types["tif"] = "image/tiff"
mime_types["tiff"] = "image/tiff"
mime_types["ts"] = "video/mp2t"
mime_types["ttf"] = "font/ttf"
mime_types["txt"] = "text/plain"
mime_types["vsd"] = "application/vnd.visio"
mime_types["wav"] = "audio/wav"
mime_types["weba"] = "audio/webm"
mime_types["webm"] = "video/webm"
mime_types["webp"] = "image/webp"
mime_types["woff"] = "font/woff"
mime_types["woff2"] = "font/woff2"
mime_types["xhtml"] = "application/xhtml+xml"
mime_types["xls"] = "application/vnd.ms-excel"
mime_types["xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
mime_types["xml"] = "application/xml"
mime_types["xul"] = "application/vnd.mozilla.xul+xml"
mime_types["zip"] = "application/zip"
mime_types["3gp"] = "video/3gpp; audio/3gpp"
mime_types["3g2"] = "video/3gpp2; audio/3gpp2"
mime_types["7z"] = "application/x-7z-compressed"

local http_status_codes: hashmap(uinteger, string)
-- 1xx Informational
http_status_codes[100] = "Continue"
http_status_codes[101] = "Switching Protocols"
http_status_codes[102] = "Processing"
http_status_codes[103] = "Early Hints"

-- 2xx Successful
http_status_codes[200] = "OK"
http_status_codes[201] = "Created"
http_status_codes[202] = "Accepted"
http_status_codes[203] = "Non-Authoritative Information"
http_status_codes[204] = "No Content"
http_status_codes[205] = "Reset Content"
http_status_codes[206] = "Partial Content"
http_status_codes[207] = "Multi-Status"
http_status_codes[208] = "Already Reported"
http_status_codes[226] = "IM Used"

-- 3xx Redirection
http_status_codes[300] = "Multiple Choices"
http_status_codes[301] = "Moved Permanently"
http_status_codes[302] = "Found (Previously Moved Temporarily)"
http_status_codes[303] = "See Other"
http_status_codes[304] = "Not Modified"
http_status_codes[305] = "Use Proxy"
http_status_codes[306] = "Switch Proxy"
http_status_codes[307] = "Temporary Redirect"
http_status_codes[308] = "Permanent Redirect"

-- 4xx Client Error
http_status_codes[400] = "Bad Request"
http_status_codes[401] = "Unauthorized"
http_status_codes[402] = "Payment Required"
http_status_codes[403] = "Forbidden"
http_status_codes[404] = "Not Found"
http_status_codes[405] = "Method Not Allowed"
http_status_codes[406] = "Not Acceptable"
http_status_codes[407] = "Proxy Authentication Required"
http_status_codes[408] = "Request Timeout"
http_status_codes[409] = "Conflict"
http_status_codes[410] = "Gone"
http_status_codes[411] = "Length Required"
http_status_codes[412] = "Precondition Failed"
http_status_codes[413] = "Payload Too Large"
http_status_codes[414] = "URI Too Long"
http_status_codes[415] = "Unsupported Media Type"
http_status_codes[416] = "Range Not Satisfiable"
http_status_codes[417] = "Expectation Failed"
http_status_codes[418] = "I'm a Teapot"
http_status_codes[421] = "Misdirected Request"
http_status_codes[422] = "Unprocessable Entity"
http_status_codes[423] = "Locked"
http_status_codes[424] = "Failed Dependency"
http_status_codes[425] = "Too Early"
http_status_codes[426] = "Upgrade Required"
http_status_codes[428] = "Precondition Required"
http_status_codes[429] = "Too Many Requests"
http_status_codes[431] = "Request Header Fields Too Large"
http_status_codes[451] = "Unavailable For Legal Reasons"

-- 5xx Server Error
http_status_codes[500] = "Internal Server Error"
http_status_codes[501] = "Not Implemented"
http_status_codes[502] = "Bad Gateway"
http_status_codes[503] = "Service Unavailable"
http_status_codes[504] = "Gateway Timeout"
http_status_codes[505] = "HTTP Version Not Supported"
http_status_codes[506] = "Variant Also Negotiates"
http_status_codes[507] = "Insufficient Storage"
http_status_codes[508] = "Loop Detected"
http_status_codes[510] = "Not Extended"
http_status_codes[511] = "Network Authentication Required"

local http = @record{}

local http.Response = @record{
  content: string,
  status: uinteger,
  content_type: string,
  headers: hashmap(string, string)
}

local http.Server <forwarddecl> = @record{}

local http.ActionFn = @function(self: *http.Server): http.Response

local Route = @record{
  methods: hashmap(string, http.ActionFn)
}

http.Server = @record{
  port: uinteger,
  routes: hashmap(string, Route),
  var_routes: hashmap(string, Route),
  static_dir: string,
  req: record{
    headers: hashmap(string, string),
    params: hashmap(string, string)
  }
}

function http.escape(s: string)
  return (string.gsub(s, "([^A-Za-z0-9_])", function(c: string)
      return string.format("%%%02x", string.byte(c))
  end))
end

function http.unescape(s: string)
  s = s:gsub("+", " ")
  return (string.gsub(s, "%%(%x%x)", function(hex: string)
      return string.char(tonumber(hex, 16))
  end))
end


function http.Response:tostring(): string
  local status_msg: string
  if http_status_codes:has(self.status) then
    status_msg = http_status_codes[self.status]
  else
    self.status = 200
    status_msg = "OK"
  end
  if self.content_type == "" then
    self.content_type = "text/html"
  end
  local formatted_date = os.date("%a, %d %b %Y %H:%M:%S GMT")
  local sb: stringbuilder
  sb:write(("HTTP/1.0 %s %s\r\n"):format(self.status, status_msg))
  sb:write("Server: http-nelua\r\n")
  sb:write(("Date: %s\r\n"):format(formatted_date))
  for k, v in pairs(self.headers) do
    sb:write(("%s: %s"):format(k, v))
  end
  sb:write(("Content-type: %s\r\n"):format(self.content_type))
  sb:write(("Content-Length: %d\r\n\r\n"):format(#self.content + 2))
  sb:write(("%s\r\n"):format(self.content))

  return sb:promote()
end

function http.Server:get(route: string, action: http.ActionFn)
  assert(not self.routes:has(route) or not self.routes[route].methods:has("GET"))
  assert(not self.var_routes:has(route) or not self.var_routes[route].methods:has("GET"))
  if route:match(":.+") then
    self.var_routes[route].methods["GET"] = action
  else
    self.routes[route].methods["GET"] = action
  end
end

function http.Server:post(route: string, action: http.ActionFn)
  assert(not self.routes:has(route) or not self.routes[route].methods:has("POST"))
  self.routes[route].methods["POST"] = action
end

function http.Server:delete(route: string, action: http.ActionFn)
  assert(not self.routes:has(route) or not self.routes[route].methods:has("DELETE"))
  self.routes[route].methods["DELETE"] = action
end

function http.Server:put(route: string, action: http.ActionFn)
  assert(not self.routes:has(route) or not self.routes[route].methods:has("PUT"))
  self.routes[route].methods["PUT"] = action
end

function http.Server:patch(route: string, action: http.ActionFn)
  assert(not self.routes:has(route) or not self.routes[route].methods:has("PATCH"))
  self.routes[route].methods["PATCH"] = action
end

function http.Server:serve()
  local BUFFER_LEN <comptime> = 2048
  local buffer: [BUFFER_LEN]cchar

  local sock_fd = socket(AF_INET, SOCK_STREAM, 0)

  if sock_fd == -1 then
    C.perror()
    os.exit(1)
  end

  local optval: integer = 1
  local sol_socket = 1
  local so_reuseaddr = 2
  setsockopt(sock_fd, sol_socket, so_reuseaddr, &optval, #integer)

  local host_addr: sockaddr_in
  host_addr.sin_family = AF_INET
  host_addr.sin_port = htons(self.port)
  host_addr.sin_addr.s_addr = htonl(inet_addr("0.0.0.0"))

  local host_addr_len: cuint = #sockaddr_in

  local bind_ok = bind(sock_fd, (@*sockaddr)(&host_addr), host_addr_len)

  if bind_ok ~= 0 then
    C.perror()
    os.exit(1)
  end


  local client_addr: sockaddr_in
  local client_addr_len: cuint = #sockaddr_in

  local MAX_CONS <const> = 128

  local listen_ok = listen(sock_fd, MAX_CONS)

  if listen_ok ~= 0 then
    C.perror()
    os.exit(1)
  end

  print("Server started on http://localhost:" .. self.port)
  while true do
    
    local accept_fd = accept(sock_fd, (@*sockaddr)(&host_addr), &host_addr_len)
    if accept_fd == -1 then
      C.perror()
      continue
    end

    defer
      close(accept_fd)
    end

    local read_bytes = read(accept_fd, &buffer, BUFFER_LEN)
    if read_bytes == -1 then
      C.perror()
      continue
    end

    local str: string = &buffer
    local code: uinteger
    local method: string, uri: string, version: string
    local request_headers: hashmap(string, string)
    local i = 0
    for line in str:gmatch("[^\r\n]*\r\n") do
      if i < 1 then
        local info_match, info_seq = line:match("(.+) (.+) (.+)")
        if info_match then
          method = info_seq[1]
          uri = info_seq[2]
          version = info_seq[3]
        end
      else
        local header_match, header_seq = line:match("(.+): ([^\r\n]+)")
        if header_match then
          request_headers[header_seq[1]] = header_seq[2]
        end
      end
      i = i + 1
    end
    self.req.headers = request_headers
    -- query params
    local param_match, param_seq = uri:match("(/.*)?(.*)")
    if param_match then
      uri = param_seq[1]
      for _, params in param_seq[2]:gmatch("([^&]*)&") do
        for _, param in params[0]:gmatch("(.*)=(.*)") do
          self.req.params[param[0]] = http.unescape(param[1])
        end
      end
    end
    -- request body params
    if request_headers:has("Content-Type") and request_headers["Content-Type"] == "application/x-www-form-urlencoded" then
      local param_match, param_seq = str:match("\r\n\r\n(.+)")
      if param_match then
        local param_str = param_seq[1] .. "&"
        for _, params in param_str:gmatch("([^&]*)&") do
          for _, param in params[0]:gmatch("(.*)=(.*)") do
            self.req.params[param[0]] = http.unescape(param[1])
          end
        end
      end
    end
    if self.static_dir == "" then
      self.static_dir = "./static"
    end
    local resp_str: string
    local resp_404: http.Response = {
      content = "<html><h1>404</h1><p>Page or resource not found</p></html>\r\n",
      status = 404
    }
    local resp_404_str = resp_404:tostring()
    if self.routes:has(uri) and self.routes[uri].methods:has(method) then 
      local resp = self.routes[uri].methods[method](self)
      resp_str = resp:tostring()
      code = resp.status
    elseif uri:match(self.static_dir:sub(2) .. ".*") then
      local ext_match, ext_seq = uri:match("^.+%.(.+)$") 
      local ext: string
      local err: boolean
      if ext_match then
        ext = ext_seq[1]
      end
      if not mime_types:has(ext) then
        err = true
      end
      local static_file = io.open("." .. uri)
      if not static_file:isopen() then
        err = true
      end
      if err then
        resp_str = resp_404_str
        code = resp_404.status
      else
        local resp: http.Response = {
          content = static_file:read("a"),
          content_type = mime_types[ext],
        }
        resp_str = resp:tostring()
        code = resp.status
      end
      static_file:close()
    elseif not self.routes:has(uri) then
      local err: boolean = true
      for path, route in pairs(self.var_routes) do
        local path_to_match = path:gsub(":([^/]+)", "([^/]+)")
        path_to_match = "^" .. path_to_match .. "$"
        local uri_match, uri_seq = uri:match(path_to_match)
        print(uri_match)
        local name_match, name_seq = path:match(path_to_match)
        if uri_match then
          -- url params
          for i, name in pairs(name_seq) do
            self.req.params[name:sub(2)] = uri_seq[i]
          end
          local resp = route.methods[method](self)
          resp_str = resp:tostring()
          code = resp.status
          err = false
          break
        end
      end
      if err then
        resp_str = resp_404_str
        code = resp_404.status
      end
    else
      resp_str = resp_404_str
      code = resp_404.status
    end

    print(code, method, uri, version)
    local written_bytes = write(accept_fd, (@cstring)(resp_str), #resp_str)
    if written_bytes == -1 then
      C.perror()
      continue
    end
  end
end

function http.new(port: uinteger): http.Server
  local s: http.Server
  s.port = port
  return s
end

return http
