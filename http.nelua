--- ### http.nelua

require "C.string"
require "C.errno"

require "os"
require "io"
require "hashmap"
require "string"

require ".thirdparty.socket"
require ".thirdparty.unistd"
require ".thirdparty.poll"

require ".thirdparty.inline_map"

local AnsiColor = require ".thirdparty.ansicolor"
local json = require ".thirdparty.json"

local Crypt = require ".libs.cryptography"
local send_request = require ".libs.send_request"
local utils = require ".libs.utils"
local logger = require ".libs.logger"

--- #### http
---`
local http = @record{}
---`

--- #### http.json
--- See [json.nelua](#jsonnelua)
---`
local http.json = json
---`
--- #### http.send_request
--- See [send_request.nelua](#send_requestnelua)
---`
local http.send_request = send_request
---`
--- #### http.utils
--- See [utils.nelua](#utilsnelua)
---`
local http.utils = utils
---`

--- #### http.Status
--- Enum list of different possible HTTP status codes
---`
local http.Status = @enum{
  Continue = 100,
  SwitchingProtocols = 101,
  Processing = 102,
  EarlyHints = 103,
  
  OK = 200,
  Created = 201,
  Accepted = 202,
  NonAuthoritativeInfo = 203,
  NoContent = 204,
  ResetContent = 205,
  PartialContent = 206,
  MultiStatus = 207,
  AlreadyReported = 208,
  IMUsed = 226,
  
  MultipleChoices = 300,
  MovedPermanently = 301,
  Found = 302,
  SeeOther = 303,
  NotModified = 304,
  UseProxy = 305,
  SwitchProxy = 306,
  TemporaryRedirect = 307,
  PermanentRedirect = 308,

  BadRequest = 400,
  Unauthorized = 401,
  PaymentRequired = 402,
  Forbidden = 403,
  NotFound = 404,
  MethodNotAllowed = 405,
  NotAcceptable = 406,
  ProxyAuthRequired = 407,
  RequestTimeout = 408,
  Conflict = 409,
  Gone = 410,
  LengthRequired = 411,
  PreconditionFailed = 412,
  RequestEntityTooLarge = 413,
  RequestURITooLong = 414,
  UnsupportedMediaType = 415,
  RequestedRangeNotSatisfiable = 416,
  ExpectationFailed = 417,
  Teapot = 418,
  MisdirectedRequest = 421,
  UnprocessableEntity = 422,
  Locked = 423,
  FailedDependency = 424,
  TooEarly = 425,
  UpgradeRequired = 426,
  PreconditionRequired = 428,
  TooManyRequests = 429,
  RequestHeaderFieldsTooLarge = 431,
  UnavailableForLegalReasons = 451,

  InternalServerError = 500,
  NotImplemented = 501,
  BadGateway = 502,
  ServiceUnavailable = 503,
  GatewayTimeout = 504,
  HTTPVersionNotSupported = 505,
  VariantAlsoNegotiates = 506,
  InsufficientStorage = 507,
  LoopDetected = 508,
  NotExtended = 510,
  NetworkAuthenticationRequired = 511,
}
---`

local function status_text(code: http.Status): string
	switch code do
	case http.Status.Continue then
		return "Continue"
	case http.Status.SwitchingProtocols then
		return "Switching Protocols"
	case http.Status.Processing then
		return "Processing"
	case http.Status.EarlyHints then
		return "Early Hints"
	case http.Status.OK then
		return "OK"
	case http.Status.Created then
		return "Created"
	case http.Status.Accepted then
		return "Accepted"
	case http.Status.NonAuthoritativeInfo then
		return "Non-Authoritative Information"
	case http.Status.NoContent then
		return "No Content"
	case http.Status.ResetContent then
		return "Reset Content"
	case http.Status.PartialContent then
		return "Partial Content"
	case http.Status.MultiStatus then
		return "Multi-Status"
	case http.Status.AlreadyReported then
		return "Already Reported"
	case http.Status.IMUsed then
		return "IM Used"
	case http.Status.MultipleChoices then
		return "Multiple Choices"
	case http.Status.MovedPermanently then
		return "Moved Permanently"
	case http.Status.Found then
		return "Found"
	case http.Status.SeeOther then
		return "See Other"
	case http.Status.NotModified then
		return "Not Modified"
	case http.Status.UseProxy then
		return "Use Proxy"
	case http.Status.TemporaryRedirect then
		return "Temporary Redirect"
	case http.Status.PermanentRedirect then
		return "Permanent Redirect"
	case http.Status.BadRequest then
		return "Bad Request"
	case http.Status.Unauthorized then
		return "Unauthorized"
	case http.Status.PaymentRequired then
		return "Payment Required"
	case http.Status.Forbidden then
		return "Forbidden"
	case http.Status.NotFound then
		return "Not Found"
	case http.Status.MethodNotAllowed then
		return "Method Not Allowed"
	case http.Status.NotAcceptable then
		return "Not Acceptable"
	case http.Status.ProxyAuthRequired then
		return "Proxy Authentication Required"
	case http.Status.RequestTimeout then
		return "Request Timeout"
	case http.Status.Conflict then
		return "Conflict"
	case http.Status.Gone then
		return "Gone"
	case http.Status.LengthRequired then
		return "Length Required"
	case http.Status.PreconditionFailed then
		return "Precondition Failed"
	case http.Status.RequestEntityTooLarge then
		return "Request Entity Too Large"
	case http.Status.RequestURITooLong then
		return "Request URI Too Long"
	case http.Status.UnsupportedMediaType then
		return "Unsupported Media Type"
	case http.Status.RequestedRangeNotSatisfiable then
		return "Requested Range Not Satisfiable"
	case http.Status.ExpectationFailed then
		return "Expectation Failed"
	case http.Status.Teapot then
		return "I'm a teapot"
	case http.Status.MisdirectedRequest then
		return "Misdirected Request"
	case http.Status.UnprocessableEntity then
		return "Unprocessable Entity"
	case http.Status.Locked then
		return "Locked"
	case http.Status.FailedDependency then
		return "Failed Dependency"
	case http.Status.TooEarly then
		return "Too Early"
	case http.Status.UpgradeRequired then
		return "Upgrade Required"
	case http.Status.PreconditionRequired then
		return "Precondition Required"
	case http.Status.TooManyRequests then
		return "Too Many Requests"
	case http.Status.RequestHeaderFieldsTooLarge then
		return "Request Header Fields Too Large"
	case http.Status.UnavailableForLegalReasons then
		return "Unavailable For Legal Reasons"
	case http.Status.InternalServerError then
		return "Internal Server Error"
	case http.Status.NotImplemented then
		return "Not Implemented"
	case http.Status.BadGateway then
		return "Bad Gateway"
	case http.Status.ServiceUnavailable then
		return "Service Unavailable"
	case http.Status.GatewayTimeout then
		return "Gateway Timeout"
	case http.Status.HTTPVersionNotSupported then
		return "HTTP Status.Version Not Supported"
	case http.Status.VariantAlsoNegotiates then
		return "Variant Also Negotiates"
	case http.Status.InsufficientStorage then
		return "Insufficient Storage"
	case http.Status.LoopDetected then
		return "Loop Detected"
	case http.Status.NotExtended then
		return "Not Extended"
	case http.Status.NetworkAuthenticationRequired then
		return "Network Authentication Required"
  else
  	return ""
  end
end


--- #### http.TriBool
---`
local http.TriBool= @enum{
  NULL = -1,
  FALSE,
  TRUE
}
---`

--- #### http.Cookie 
---`
local http.Cookie = @record{
  name: string,
  val: string,
  path: string,
  domain: string,
  expires: string,
  secure: http.TriBool,
  httpOnly: http.TriBool
}
---`

--- #### http.Response
---`
local http.Response = @record{
  body: string,
  status: http.Status,
  content_type: string,
  headers: hashmap(string, string),
  cookies: sequence(http.Cookie)
}
---`

--- #### http.Response:destroy
--- Destorys the response object and sets it to a zeroed state
---`
function http.Response:destroy()
---`
  self.headers:destroy()
  self.cookies:destroy()
  self = (@*http.Response)()
end

--- #### http.Response:tostring
--[[-
This function converts your response into a http request string

```:lang:
app:get(nil, "/test", function(self: *http.Server)
  local resp = self:text(200, "ok")
  print(resp:tostring()) -- "HTTP/1.1 200 OK\r\nServer: http-nelua\r\nDate: Thu, 17 Apr 2025 19:23:00 GMT\r\nContent-type: text/plain\r\nContent-Length: 4\r\n\r\nok\r\n"
  return resp
end)
```
-]]
---`
function http.Response:tostring(): string
---`
  local status_msg = status_text(self.status)
  if self.content_type == "" then
    self.content_type = "text/html"
  end
  local sb: stringbuilder
  sb:write(("HTTP/1.1 %s %s\r\n"):format(self.status, status_msg))
  if not (self.headers:has("Server") and self.headers["Server"] == "") then
    sb:write("Server: http-nelua\r\n")
  end
  if not (self.headers:has("Date") and self.headers["Date"] == "") then
    local formatted_date = os.date("!%a, %d %b %Y %H:%M:%S GMT")
    sb:write(("Date: %s\r\n"):format(formatted_date))
  end
  if not (self.headers:has("Content-type") and self.headers["Content-type"] == "") then
    sb:write(("Content-type: %s\r\n"):format(self.content_type))
  end
  if not (self.headers:has("Content-Length") and self.headers["Content-Length"] == "") then
    sb:write(("Content-Length: %d\r\n"):format(#self.body + 2))
  end
  for k, v in pairs(self.headers) do
    if k ~= "" and v ~= "" then
      sb:write(("%s: %s\r\n"):format(k, v))
    end
  end
  for _, v in ipairs(self.cookies) do
    if v.name ~= "" or v.val ~= "" then 
      sb:write(("Set-Cookie: %s=%s"):format(v.name, v.val))
      if v.path ~= "" then
        sb:write(("; Path=%s"):format(v.path))
      end
      if v.domain ~= "" then
        sb:write(("; Domain=%s"):format(v.domain))
      end
      if v.expires ~= "" then
        sb:write(("; Expires=%s"):format(v.expires))
      end
      if v.secure == http.TriBool.NULL or v.secure == http.TriBool.TRUE then
        sb:write(("; Secure"):format(v.secure))
      end
      if v.httpOnly == http.TriBool.NULL or v.httpOnly == http.TriBool.TRUE then
        sb:write(("; HttpOnly"):format(v.httpOnly))
      end
      sb:write("\r\n")
    end
  end
  sb:write("\r\n")
  sb:write(("%s\r\n"):format(self.body))

  return sb:promote()
end

--- #### http.Response:set_header
--[[-
Sets a header to be sent with the response
```:lang:
app:get(nil, "/", function(self: *http.Server)
  local resp = self:text(200, "ok")
  local err = resp:set_header("name", "james")
  if err ~= "" then
    return self:error()
  end
  return resp
end)
```
-]]
---`
function http.Response:set_header(key: string, val: string):  string
---`
  if key == "" then
    return "Key cannot be an empty string"
  end
  self.headers[key] = val
  return ""
end

--- #### http.Response:set_cookie
--[[-
Sets a cookie to be sent with the response

```:lang:
app:get(nil, "/", function(self: *http.Server)
  local resp = self:text(200, "ok")
  local err = resp:set_cookie({
    name = "name",
    val = "james"
  })
  if err ~= "" then
    return self:error()
  end
  return resp
end)
```
-]]
---`
function http.Response:set_cookie(c: http.Cookie):  string
---`
  if c.name == "" then
    return "A cookie value cannot have an empty string for its name"
  end
  if c.val == "" then
    return "A cookie value cannot have an empty string for its val"
  end
  self.cookies:push(c)
  return ""
end

local http.Server <forwarddecl> = @record{}

--- #### http.Session
---`
local http.Session = @record{
  vals: hashmap(string, string),
  send: boolean
}
---`

--- #### http.Session:set_val
--[[-
This function is used to set values that will be stored in the sesssion

```:lang:
app:get(nil, "/", function(self: *http.Server)
  self.session:set_val("name", "james")
  self.session:set_val("age", "10")
  return self:text(200, "ok")
end)
```
-]]
---`
function http.Session:set_val(name: string, val: string): string
---`
  if name == "" then
    return "A session value cannot have an empty string for its name"
  end
  self.vals[name] = val
  self.send = true
  return ""
end

--- #### http.Session:get_val(name: string): string
--[[-
This function is used to get values that are stored in the sesssion

```:lang:
app:get(nil, "/test", function(self: *http.Server)
  local name = self.session:get_val("name")
  local age = self.session:get_val("age")
  return self:text(200, "ok")
end)
```
-]]
function http.Session:get_val(name: string): string
  if not self.vals:has(name) then return "" end
  return self.vals[name]
end

--- #### http.Request
---`
local http.Request = @record{
  method: string,
  version: string,
  headers: hashmap(string, string),
  current_path: string,
  params: hashmap(string, string),
  body: string
}
---`

--- #### http.Request:get_header
--[[-
Gets a header from the request object

```:lang:
app:get(nil, "/test", function(self: *http.Server)
  local name = self.req:get_header("name")
  return self:text(200, "ok")
end)
-]]
---`
function http.Request:get_header(name: string): string
---`
  if not self.headers:has(name) then
    return ""
  end
  return self.headers[name]
end

--- #### http.Request:get_cookie
--[[-
Gets a cookie from the request object

```:lang:
app:get(nil, "/test", function(self: *http.Server)
  local name = self.req:get_cookie("name")
  return self:text(200, "ok")
end)
-]]
---`
function http.Request:get_cookie(name: string): string
---`
  local cookies = self:get_header("Cookie") .. ";"
  for _, cookie_span in cookies:gmatch("([%w_]+)=([^;]+);") do
    if cookie_span[0] == name then
      return cookie_span[1]
    end
  end
  return ""
end

--- #### http.Config
--[[-
Defaults are only set if the server is instantiated with [http.Server.new](#httpservernew)
- port: The port you want the server to run on, default is `8080`
- bind_host: The interface the server will bind to, default is `0.0.0.0`
- secret: This is used to sign your session, default is `please-change-me`
- session_name: Name of cookie used to store the session, default is `http_session`
- log: This determines whether the server will log the request information to the console, default is [http.TriBool](#httptribool).NULL
-]]
---`
local http.Config = @record{
  port: uinteger,
  bind_host: string,
  secret: string,
  session_name: string,
  log: http.TriBool
}
---`

--- #### http.BeforeFn
--- Type Alias describing the function signature of before functions called in the [http.Server:before_filter](#httpserverbefore_filter)
---`
local http.BeforeFn = @function(self: *http.Server): (boolean, http.Response)
---`

--- #### http.ActionFn
--- Type Alias describing the function signature of action functions called on a [http.Server:#|method|#](#httpservermethod)
---`
local http.ActionFn = @function(self: *http.Server): http.Response
---`

local Route = @record{
  methods: hashmap(string, http.ActionFn)
}

--- #### http.Server
---`
http.Server = @record{
  config: http.Config,
  static_dir: string,
  static_name: string,
  static_headers: hashmap(string, string),
  routes: hashmap(string, Route),
  var_routes: hashmap(string, Route),
  named_routes: hashmap(string, string),
  req: http.Request,
  default_route: http.ActionFn,
  handle_404: http.ActionFn,
  session: http.Session,
  before_funcs: sequence(http.BeforeFn),
  write: function(self: *http.Server, s: string): (boolean, string),
  written: boolean,
  _fd: integer
}
---`

--- #### Supported mime types
--- These are the mime types that will be matched against when a static file is requested from the server alongside their respective content type
---`
local mime_types = inline_map!(string, string, {
  ["aac"] = "audio/aac",
  ["abw"] = "application/x-abiword",
  ["apng"] = "image/apng",
  ["arc"] = "application/x-freearc",
  ["avif"] = "image/avif",
  ["avi"] = "video/x-msvideo",
  ["azw"] = "application/vnd.amazon.ebook",
  ["bin"] = "application/octet-stream",
  ["bmp"] = "image/bmp",
  ["bz"] = "application/x-bzip",
  ["bz2"] = "application/x-bzip2",
  ["cda"] = "application/x-cdf",
  ["csh"] = "application/x-csh",
  ["css"] = "text/css",
  ["csv"] = "text/csv",
  ["doc"] = "application/msword",
  ["docx"] = "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
  ["eot"] = "application/vnd.ms-fontobject",
  ["epub"] = "application/epub+zip",
  ["gz"] = "application/gzip",
  ["gif"] = "image/gif",
  ["htm"] = "text/html",
  ["html"] = "text/html",
  ["ico"] = "image/vnd.microsoft.icon",
  ["ics"] = "text/calendar",
  ["jar"] = "application/java-archive",
  ["jpeg"] = "image/jpeg",
  ["jpg"] = "image/jpeg",
  ["js"] = "text/javascript",
  ["json"] = "application/json",
  ["jsonld"] = "application/ld+json",
  ["mid"] = "audio/midi",
  ["midi"] = "audio/x-midi",
  ["mjs"] = "text/javascript",
  ["mp3"] = "audio/mpeg",
  ["mp4"] = "video/mp4",
  ["mpeg"] = "video/mpeg",
  ["mpkg"] = "application/vnd.apple.installer+xml",
  ["odp"] = "application/vnd.oasis.opendocument.presentation",
  ["ods"] = "application/vnd.oasis.opendocument.spreadsheet",
  ["odt"] = "application/vnd.oasis.opendocument.text",
  ["oga"] = "audio/ogg",
  ["ogv"] = "video/ogg",
  ["ogx"] = "application/ogg",
  ["opus"] = "audio/ogg",
  ["otf"] = "font/otf",
  ["png"] = "image/png",
  ["pdf"] = "application/pdf",
  ["php"] = "application/x-httpd-php",
  ["ppt"] = "application/vnd.ms-powerpoint",
  ["pptx"] = "application/vnd.openxmlformats-officedocument.presentationml.presentation",
  ["rar"] = "application/vnd.rar",
  ["rtf"] = "application/rtf",
  ["sh"] = "application/x-sh",
  ["svg"] = "image/svg+xml",
  ["tar"] = "application/x-tar",
  ["tif"] = "image/tiff",
  ["tiff"] = "image/tiff",
  ["ts"] = "video/mp2t",
  ["ttf"] = "font/ttf",
  ["txt"] = "text/plain",
  ["vsd"] = "application/vnd.visio",
  ["wav"] = "audio/wav",
  ["weba"] = "audio/webm",
  ["webm"] = "video/webm",
  ["webp"] = "image/webp",
  ["woff"] = "font/woff",
  ["woff2"] = "font/woff2",
  ["xhtml"] = "application/xhtml+xml",
  ["xls"] = "application/vnd.ms-excel",
  ["xlsx"] = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
  ["xml"] = "application/xml",
  ["xul"] = "application/vnd.mozilla.xul+xml",
  ["zip"] = "application/zip",
  ["3gp"] = "video/3gpp; audio/3gpp",
  ["3g2"] = "video/3gpp2; audio/3gpp2",
  ["7z"] = "application/x-7z-compressed",
})
---`

--- #### http.Server:set_static
--[[-
This sets the directory when static files will be read from as well as the name that will be used for routing

```:lang:
local app = http.Server.new()

app:set_static("./static", "static")

app:get(nil, "/", function(self: *http.Server): http.Response
  return self:html(200, '<link rel="stylesheet" href="/static/test.css" />')
end)
```
-]]
---`
function http.Server:set_static(dir: string, name: string)
---`
  assert(dir ~= "", "Static directory path can not be an empty string")
  assert(name ~= "", "Static directory name can not be an empty string")
  self.static_dir = dir
  self.static_name = name
end

--- #### http.Server:before_filter
--[[-
This adds functions that will run before every request
The [http.BeforeFn](#httpbeforefn) returns a boolean and a [http.Response](#httpresponse), if the boolean is `true`, it will return the response instead of the hit route

```:lang:
app:before_filter(function(self: *http.Server): (boolean, http.Response)
  self.session:set_val("val", "test")
  if self.req.current_path ~= self:url_for("test") and self.session:get_val("val") == "test" then
    return true, self:redirect("/test")
  end
  return false, {}
end)
```
-]]
---`
function http.Server:before_filter(fn: http.BeforeFn)
---`
  self.before_funcs:push(fn)
end

--- #### Supported HTTP Methods
---`
## local methods = {"get", "post", "put", "patch", "delete"}
---`

## for _, method in ipairs(methods) do

--- #### http.Server:#|method|#
--[[-
These are routing functions where `method` could be one of the [supported http methods](#supported-http-methods)

```:lang:
local http = require "path.to.http"

local app = http.Server.new()

app:get(nil, "/", function(self: *http.Server): http.Response
  return self:text(http.Status.OK, "hello, world")
end)
```
- name: This can be provided to set a name for a route, usually to be used with the [http.Server:url_for](#httpserverurlfor) function
- route: The actual route that will be called
- action: The function to be called when the route is hit
-]]
---`
function http.Server:#|method|#(name: facultative(string), route: string, action: http.ActionFn)
---`
  assert(not self.routes:has(route) or not self.routes[route].methods:has(#[method:upper()]#), ("A route can not have it's methods redefined: `%s`"):format(route))
  assert(not self.var_routes:has(route) or not self.var_routes[route].methods:has(#[method:upper()]#), ("A route can not have it's methods redefined: `%s`"):format(route))
  ## if not name.type.is_niltype then
    assert(name ~= "", ("Route name can not be an empty string: `%s`"):format(route))
    if self.named_routes:has(name) then
      assert(self.named_routes[name] == route, ("A name can not be used with more than one route group: `%s -> %s`"):format(name, route))
    else
      self.named_routes[name] = route
    end
  ## end
  if route:match("[:%*]+.*") then
    self.var_routes[route].methods[#[method:upper()]#] = action
  else
    self.routes[route].methods[#[method:upper()]#] = action
  end
end
## end

--- #### http.Server.UrlForOpts
--- Used to alter the returned url from [http.Server:url_for](#httpserverurl_for)
---`
local http.Server.UrlForOpts = @record{
  route_params: hashmap(string, string),
  query_params: hashmap(string, string)
}
---`

--- #### http.Server:url_for
--[[-
This function returns the route of the relevant name
`opts` can be passed to the function to help build a url if it contains route params or you would like to add query params, see [http.Server.UrlForOpts](#httpserverurlforopts)

Examples:

```:lang:
app:get("get_params", "/get_params", function(self: *http.Server)
  local route_params: hashmap(string, string)
  route_params["id"]   = "10"
  route_params["name"] = "james"
  route_params["*"]    = "splat"

  local query_params: hashmap(string, string)
  query_params["id"]   = "10"
  query_params["name"] = "james"
  return self:html(200, ("<a href='%s'>link</a>"):format(self:url_for("params", {
    route_params = route_params,
    query_params = query_params
  })))
end)

app:get("params", "/params/:id/:name/*", function(self: *http.Server)
  return self:text(200, self.req.params["id"] .. " " .. self.req.params["name"] .. " " .. self.req.params["*"])
end)
-- Should return "/params/10/james/splat?id=10&name=james"
```

```:lang:
app:get(nil, "/", function(self: *http.Server): http.Response
  return self:text(http.Status.OK, self:url_for("test"))
end)
-- will return "/really-long-name"

app:get("test", "/really-long-name", function(self: *http.Server): http.Response
  return self:text(http.Status.OK, "hello, world")
end)
```
-]]
---`
function http.Server:url_for(name: string, opts: http.Server.UrlForOpts): string
---`
  if self.named_routes:has(name) then
    local sb: stringbuilder
    local url = self.named_routes[name]
    url = url:gsub(":([^/]+)", opts.route_params)
    url = url:gsub("([%*]+)", opts.route_params, 1)
    sb:write(url)
    local i = 0
    for k, v in pairs(opts.query_params) do
      if i == 0 then
        sb:write("?")
      end
      sb:writef("%s=%s&", k, v)
      i = i + 1
    end
    if i > 0 then
      sb:rollback(1)
    end
    return sb:promote()
  end
  return ""
end

--- #### http.Server:html
--- helper function for commonly returned [http.Response](#httpresponse) to specify the response is `html`
---`
function http.Server:html(code: http.Status, html: string): http.Response
---`
  return {
    body = html,
    status =  code,
    content_type =  "text/html"
  }
end

--- #### http.Server:json
--[[-
helper function for commonly returned [http.Response](#httpresponse) to specify the response is `json`
-`body`: Can either be a string or a json serializable object
-]]
---`
function http.Server:json(code: http.Status, body: overload(string, auto)): http.Response
---`
  ## if body.type.is_string then
    local val = body
  ## else
    ## static_assert(rec.type.is_record, "Parameter `rec` must be of type `record`")
    local val = json.serialize_record(body)
  ## end
  return {
    body = val,
    status =  code,
    content_type =  "application/json"
  }
end

--- #### http.Server:text
--- helper function for commonly returned [http.Response](#httpresponse) to specify the response is `text`
---`
function http.Server:text(code: http.Status, text: string): http.Response
---`
  return {
    body = text,
    status =  code,
    content_type =  "text/plain"
  }
end

--- #### http.Server:redirect
--[[-
helper function to specify that the return should be a redirect and redirect to `path`

```:lang:
app:get(nil, "/", function(self: *http.Server): http.Response
  return self:redirect(self:url_for("actual"))
end)

app:get("actual", "/actual-path", function(self: *http.Server): http.Response
  return self:text(http.Status.OK, "ok")
end)
```
-]]
---`
function http.Server:redirect(path: string): http.Response
---`
  local headers: hashmap(string, string)
  headers["Location"] = path
  return {
    status = http.Status.Found,
    headers = headers,
    body = self.req.body
  }
end

--- #### http.Server:error
--- Helper function that returns a http text response with a 500 error code and message "Internal Server Error"
---`
function http.Server:error(): http.Response
---`
  return self:text(http.Status.InternalServerError, "Internal Server Error")
end

--- #### http.csrf
---`
local http.csrf = @record{}
---`

--- #### http.csrf.generate_token
--[[-
This function generates a csrf token that is stored in your session and returns it as a value
If a token already exists, it returns that and doesn't create a new one

```:lang:
app:before_filter(function(self: *http.Server): (boolean, http.Response)
  local token = http.csrf.generate_token(self)
  return false, {}
end)
```
-]]
---`
function http.csrf.generate_token(self: *http.Server): string
---`
  local token = self.session:get_val("csrf_token")
  if token ~= "" then
    return token
  end
  local TOKEN_LENGTH <comptime> = 32 -- 32 bytes = 256 bits
  local buf: [TOKEN_LENGTH]cchar
  if Crypt.rand_bytes(&buf, #buf) ~= 1 then
    return ""
  end

  local val = Crypt.get_hex(&buf, #buf)
  self.session:set_val("csrf_token", val)
  return val
end

--- #### http.csrf.validate_token
--[[-
This function checks that there is a csrf token in your session and that the token passed in your request params matches it

```:lang:
app:post(nil, "/test", function(self: *http.Server)
  if not http.csrf.validate_token(self) then
    return self:text(403, "forbidden")
  end
  return self:text(200, "ok")
end)
```
-]]
---`
function http.csrf.validate_token(self: *http.Server): boolean
---`
  if self.session:get_val("csrf_token") == "" then
    return false
  end
  if self.req.params["csrf_token"] ~= self.session:get_val("csrf_token") then
    return false
  end
  return true
end

local function color_status(status: http.Status): string
  local color = AnsiColor.new(("%d"):format(status))
  if status >= 200 and status < 300 then
    color:Green()
  elseif status >= 300 and status < 400 then
    color:Yellow()
  elseif status >= 400 and status < 500 then
    color:Magenta()
  elseif status >= 500 and status < 600 then
    color:Red()
  end
  return color:Bright():tostring()
end

local function escape_special(s: string)
  local s = s:gsub("([%(%)%.%%%+%-%*%?%[%]%^%$])", "%%%1")
  return s
end

local function handle_request(buffer_str: string, self: *http.Server): http.Response
  local method: string, uri: string, version: string
  local request_headers: hashmap(string, string)
  local i = 0
  for line in buffer_str:gmatch("[^\r\n]*\r\n") do
    if i < 1 then
      local info_match, info_seq = line:match("(.+) (.+) (.+)")
      if info_match then
        method = info_seq[1]
        uri = info_seq[2]
        version = info_seq[3]:sub(1, #info_seq[3] - 2)
      end
    else
      local header_match, header_seq = line:match("(.+): ([^\r\n]+)")
      if header_match then
        request_headers[header_seq[1]] = header_seq[2]
      end
    end
    i = i + 1
  end

  self.req.method = method
  self.req.version = version
  self.req.headers = request_headers
  self.req.current_path = uri
  self.req.params = {}
  -- query params
  local param_match, param_seq = uri:match("(/.*)?(.*)")
  if param_match then
    uri = param_seq[1]
    for _, param in param_seq[2]:gmatch("([^&=?]+)=([^&=?]+)") do
      self.req.params[param[0]] = http.utils.url_unescape(param[1])
    end
  end
  -- request body params
  local body_match, body_seq = buffer_str:match("\r\n\r\n(.+)")
  if body_match then
    self.req.body = body_seq[1]
    -- TODO: Write test for different form content types
    if self.req.headers:has("Content-Type") then
      if self.req.headers["Content-Type"]:match("application/x%-www%-form%-urlencoded") then
        local body_str = body_seq[1] .. "&"
        for _, params in body_str:gmatch("([^&]*)&") do
          for _, param in params[0]:gmatch("(.*)=(.*)") do
            self.req.params[param[0]] = http.utils.url_unescape(param[1])
          end
        end
      elseif self.req.headers["Content-Type"]:match("multipart/form%-data") then
        local boundary_match, boundary_seq = self.req.headers["Content-Type"]:match("boundary=([^\r\n]+)")
        if boundary_match then
          local boundary = "%-%-" .. escape_special(boundary_seq[1])
          for _, part in self.req.body:gmatch("(.-)\r\n" .. boundary, #boundary) do
            local name_match, name_seq = part[0]:match('name="([^"]+)"\r\n')
            local filename_match, filename_seq = part[0]:match('filename="([^"]+)"\r\n')
            local val_match, val_seq = part[0]:match("\r\n\r\n(.*)$")
            local val = val_seq[1]
            -- TODO: Document how files are stored
            if filename_match then
              val = filename_seq[1] .. "__;__" .. val
            end
            self.req.params[name_seq[1]] = val
          end
        end
      end
    end
  end

  self.session.vals = {}
  local cookie, err = self.req:get_cookie(self.config.session_name)
  if cookie ~= "" then
    local match, match_seq = cookie:match("(.+)///(.+)")
    local signature = http.utils.b64_decode(match_seq[2])
    if signature == http.utils.sign(self.config.secret, match_seq[1]) then
    local decoded_vals = http.utils.b64_decode(match_seq[1])
      for _, vals in decoded_vals:gmatch("([%w_]+)=([^;]+);") do
        self.session.vals[vals[0]] = vals[1]
      end
    end 
  end

  local resp: http.Response

  local function send_session(self: *http.Server, resp: *http.Response)
    if self.session.send then
      local sb: stringbuilder
      for k, v in pairs(self.session.vals) do
        sb:write(("%s=%s; "):format(k, v))
      end
      sb:rollback(1)
      local session_map = http.utils.b64_encode(sb:promote()) 
      local val = session_map .. "///" .. http.utils.b64_encode(http.utils.sign(self.config.secret, session_map)) 
      resp:set_cookie({
        name = self.config.session_name,
        val = val
      })
      self.session.send = false
    end
  end

  for _, fn in ipairs(self.before_funcs) do
    local stop, early_resp = fn(self)
    if stop then
      resp = early_resp
      send_session(self, &resp)
      return resp
    end
  end
  if self.routes:has(uri) and self.routes[uri].methods:has(method) then 
    resp = self.routes[uri].methods[method](self)
    send_session(self, &resp)
  elseif uri:match("^/".. self.static_name .. ".*") then
    local ext_match, ext_seq = uri:match("^.+%.(.+)$") 
    local ext: string
    local err: boolean
    if ext_match then
      ext = ext_seq[1]:lower()
    end
    if not mime_types:has(ext) then
      err = true
    end
    local path = self.static_dir .. uri:sub(#self.static_name + 2)
    local static_file = io.open(path)
    if not static_file:isopen() then
      err = true
    end
    if err then
      resp = self:default_route()
    else
      resp = {
        status = 200,
        body = static_file:read("a"),
        content_type = mime_types[ext],
      }
      if not self.static_headers:has("Cache-Control") then
        self.static_headers["Cache-Control"] = "public, max-age=31536000"
      end
      for k, v in pairs(self.static_headers) do
        resp.headers[k] =  v
      end
    end
    static_file:close()
  else
    local err: boolean = true
    for path, route in pairs(self.var_routes) do
      local path_to_match = path:gsub(":([^/]+)", "([^/]+)"):gsub("%*", "(.*)")
      path_to_match = "^" .. path_to_match .. "$"
      local uri_match, uri_seq = uri:match(path_to_match)
      local name_match, name_seq = path:match(path_to_match)
      if uri_match then
        -- url params
        for i, name in pairs(name_seq) do
          if name:match("%*") then
            self.req.params[name] = uri_seq[i]
          else
            self.req.params[name:sub(2)] = uri_seq[i]
          end
        end
        if route.methods:has(method) then
          resp = route.methods[method](self)
          send_session(self, &resp)
          err = false
        end
        break
      end
    end
    if err then
      resp = self:default_route()
    end
  end

  return resp
end

--- #### http.Server:serve
--[[-
This function starts the server
It should always be the last line of your file
-]]
---`
function http.Server:serve()
---`
  local listen_fd: integer, new_fd: integer
  local server_addr: sockaddr_in, client_addr: sockaddr_in
  local client_len: cuint = #sockaddr_in
  local MAX_CLIENTS <comptime> = 1024

  local general_allocator: GeneralAllocator
  local fds: *[0]pollfd = (@*[0]pollfd)(general_allocator:alloc(MAX_CLIENTS * #pollfd))
  local nfds = 1
  local i = 0

  listen_fd = socket(AF_INET, SOCK_STREAM, 0)
  if (listen_fd < 0) then
    local err_msg = C.strerror(C.errno)
    io.stderr:write(err_msg .. "\n")
    os.exit(1)
  end

  local opt = 1
  local sol_socket = 1
  local so_reuseaddr = 2
  setsockopt(listen_fd, sol_socket, so_reuseaddr, &opt, #integer)

  C.memset(&server_addr, 0, #sockaddr_in)
  server_addr.sin_family = AF_INET
  server_addr.sin_addr.s_addr = htonl(inet_addr(self.config.bind_host))
  server_addr.sin_port = htons(self.config.port)

  if bind(listen_fd, (@*sockaddr)(&server_addr), #sockaddr_in) < 0 then
    local err_msg = C.strerror(C.errno)
    io.stderr:write(err_msg .. "\n")
    os.exit(1)
  end

  local MAX_CONS <const> = 128
  if listen(listen_fd, MAX_CONS) < 0 then
    local err_msg = C.strerror(C.errno)
    io.stderr:write(err_msg .. "\n")
    os.exit(1)
  end

  fds[0].fd = listen_fd
  fds[0].events = POLLIN

  for i = 1, <MAX_CLIENTS do
    fds[i].fd = -1
  end

  print("Server started on http://localhost:" .. self.config.port)

  while true do
    local poll_count = poll(fds, nfds, -1)
    if (poll_count < 0) then
      local err_msg = C.strerror(C.errno)
      io.stderr:write(err_msg .. "\n")
      os.exit(1)
    end

    if (fds[0].revents & POLLIN == 1) then
      new_fd = accept(listen_fd, (@*sockaddr)(&client_addr), &client_len)
      if (new_fd < 0) then
        local err_msg = C.strerror(C.errno)
        io.stderr:write(err_msg .. "\n")
        continue
      end
      for i = 1, < MAX_CLIENTS do
        if (fds[i].fd == -1) then
          fds[i].fd = new_fd
          fds[i].events = POLLIN
          if (i >= nfds) then
            nfds = i + 1
          end
          break
        end
      end
      if (i == MAX_CLIENTS) then
        io.stderr:write("Too many connections\n")
        close(new_fd)
      end
      poll_count = poll_count - 1
      if (poll_count <= 0) then
        continue
      end
    end

    for i = 1, < nfds do
      if (fds[i].fd == -1) then
        continue
      end

      if (fds[i].revents & POLLIN == 1) then
        local buffer: [8192]cchar
        local bytes = read(fds[i].fd, &buffer, #buffer - 1)
        if (bytes <= 0) then
          close(fds[i].fd)
          fds[i].fd = -1
        else
          buffer[bytes] = 0
          local str: string = &buffer
          self._fd = fds[i].fd
          
          local resp = handle_request(str, self)

          if not self.written then
            self.written = self:write(resp:tostring())
          end
          logger.log(self.config.log, ("[%s] %s %s"):format(
            color_status(resp.status),
            AnsiColor.new(("%s %s"):format(self.req.method, self.req.current_path)):Cyan():Bright():tostring(),
            self.req.version)
          )
          self.written = false
          close(self._fd)
          self._fd = -1
          resp:destroy()
        end
        poll_count = poll_count - 1
        if (poll_count <= 0) then
          break
        end
      end
    end
  end

  general_allocator:dealloc(fds)
  close(listen_fd)
end

--- #### http.MockRequestOpts
---`
local http.MockRequestOpts = @record{
  method: string,
  params: hashmap(string, string),
  headers: hashmap(string, string),
  cookies: hashmap(string, string),
  session_vals: hashmap(string, string)
}
---`

--- #### http.Server:mock_request
--- This function is meant for testing and helps you simulate requests to your server
---`
function http.Server:mock_request(path: string, opts: http.MockRequestOpts): (http.Response, string)
---`
  local sb: stringbuilder
  local param_str: string
  if next(opts.params) then
    local param_sb: stringbuilder
    for k, v in pairs(opts.params) do
      param_sb:writef("%s=%s&", k, v)
    end
    param_sb:rollback(1)
    param_str = param_sb:promote()
  end

  local method = opts.method ~= "" and opts.method or "get"
  method = method:lower()
  sb:writef("%s", method:upper())

  if param_str ~= "" and method == "get" then
    sb:writef(" %s", path .. "?" .. param_str)
  else
    sb:writef(" %s", path)
  end
  sb:write(" HTTP/1.1\r\n")
  for k, v in pairs(opts.headers) do
    sb:writef("%s: %s\r\n", k, v)
  end
  if not opts.headers:has("Host") then
    sb:write("Host: localhost\r\n")
  end
  if not opts.headers:has("Content-Type") and (method == "post" or method == "put" or method == "patch" or method == "delete") then
    sb:write("Content-Type: application/x-www-form-urlencoded\r\n")
    if not opts.headers:has("Content-Length") then
      sb:writef("Content-Length: %d\r\n", #param_str)
    end
  end
  if next(opts.cookies) then
    sb:write("Cookie:")
    for k, v in pairs(opts.cookies) do
      sb:writef(" %s=%s;", k, v)
    end
  end
  if next(opts.session_vals) then
    if not next(opts.cookies) then
      sb:write("Cookie: ")
    end
    local session_sb: stringbuilder
    for k, v in pairs(opts.session_vals) do
      session_sb:write(("%s=%s; "):format(k, v))
    end
    session_sb:rollback(1)
    local session_map = http.utils.b64_encode(session_sb:promote()) 
    local val = session_map .. "///" .. http.utils.b64_encode(http.utils.sign(self.config.secret, session_map)) 
    sb:writef("%s=%s;", self.config.session_name, val)
    if not next(opts.cookies) then
      sb:rollback(1)
      sb:write("\r\n")
    end
  end
  if next(opts.cookies) then
    sb:rollback(1)
    sb:write("\r\n")
  end
  sb:write("\r\n")

  if param_str ~= "" and method == "post" or method == "put" or method == "patch" or method == "delete" then
    sb:write(param_str)
  end
  local req_str = sb:promote()
  return handle_request(req_str, self), req_str
end

--- #### http.Server.new
--[[-
This function returns a new [http.Server](#httpserver) instance that will be used throughout your app

The `config` param can be ommited and default values will be used, it is of type [http.Config](#httpconfig)

```:lang:
local http = require "path.to.http"

local app = http.new({
  secret = os.getenv("SECRET"),
  session_name = "my_app"
})
```
-]]
---`
function http.Server.new(config: http.Config): http.Server
---`
  config.port = config.port == 0 and 8080 or config.port
  config.bind_host = config.bind_host == "" and "0.0.0.0" or config.bind_host
  config.session_name = config.session_name == "" and "http_session" or config.session_name
  config.secret = config.secret == "" and "please-change-me" or config.secret
  local s: http.Server
  s.config = config
  s.static_dir = "./static"
  s.static_name = "static"

--[[-
To write to the client, the `write` method is called
Below is the default implementation
-]]
---`
  s.write = function(self:*http.Server, s: string): (boolean, string)
    local written_bytes = send(self._fd, (@cstring)(s), #s, MSG_NOSIGNAL)
    if written_bytes == -1 then
      local err_msg = C.strerror(C.errno)
      return false, (@string)(err_msg)
    end
    return true, ""
  end
---`

--[[-
When a request does not match any of the routes you've defined, the `default_route` method will be called to create a response.
Below is the default implementation
-]]
---`
  s.default_route = function(self: *http.Server)
    if self.req.current_path:match("./$") then
      local stripped = self.req.current_path:sub(1, #self.req.current_path - 1)
      return self:redirect(stripped)
    else
      return self:handle_404()
    end
  end
---`

--[[-
In the default `default_route`, the method `handle_404` is called when the path of the request did not match any routes.
Below is the default implementation
-]]
---`
  s.handle_404 = function(self: *http.Server)
    return self:text(http.Status.NotFound, "Page or resource not found")
  end
---`
  return s
end

return http
