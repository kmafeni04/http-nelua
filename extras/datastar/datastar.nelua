local http = require "...http"
local json = http.json

local datastar = @record{}

local datastar.ServerSentEventGenerator = @record{
  server: *http.Server,
  resp: http.Response
}

function datastar.ServerSentEventGenerator.new(server: *http.Server, resp: http.Response): (datastar.ServerSentEventGenerator, string) 
  if server == nilptr then
    return  {}, "Server was a nilptr"
  end

  resp.status = 200
  resp.content_type = "text/event-stream"
  local err = resp:set_header("Content-Length", "")
  if err ~= "" then
    return {}, err
  end
  local err = resp:set_header("Cache-Control", "nocache")
  if err ~= "" then
    return {}, err
  end
  local err = resp:set_header("Connection", "keep-alive")
  if err ~= "" then
    return {}, err
  end

  local err = server:write(resp:tostring())
  if err ~= "" then
    return {}, err
  end
  return { server = server, resp = resp }, ""
end

local EventType = @enum{
  PatchElements = 0,
  PatchSignals,
}

local function event_type_text(e_type: EventType): string
  switch e_type do
    case EventType.PatchElements then
      return "datastar-patch-elements"
    case EventType.PatchSignals then
      return "datastar-patch-signals"
  end
  return "UNKNOWN EventType: " .. e_type
end

local SendOpts = @record{
  event_id: string,
  retry_duration: uinteger
}

local function send(
  self: *datastar.ServerSentEventGenerator,
  event: EventType,
  data: sequence(string),
  opts: facultative(SendOpts)
): string
  local sb: stringbuilder

  sb:write(("event: %s\n"):format(event_type_text(event)))
  ## if not opts.type.is_niltype then
    if opts.event_id ~= "" then
      sb:write(("id: %s\n"):format(opts.event_id))
    end
    if opts.retry_duration ~= 0 and opts.retry_duration ~= 1000 then
      sb:write(("retry: %d\n"):format(opts.retry_duration))
    end
  ## end
  for i, v in ipairs(data) do
    sb:write(("data: %s\n"):format(v))
  end
  sb:write("\n")

  local final = sb:promote()
  return self.server:write(final)
end

local datastar.ElementPatchMode = @enum{
  not_set = 0,
  Morph,
  Inner,
  Outer,
  Replace,
  Prepend,
  Append,
  Before,
  After,
  Remove,
}

local function element_patch_mode_text(fmm: datastar.ElementPatchMode): string
  switch fmm do
    case datastar.ElementPatchMode.Outer then
      return "outer"
    case datastar.ElementPatchMode.Inner then
      return "inner"
    case datastar.ElementPatchMode.Replace then
      return "replace"
    case datastar.ElementPatchMode.Prepend then
      return "prepend"
    case datastar.ElementPatchMode.Append then
      return "append"
    case datastar.ElementPatchMode.Before then
      return "before"
    case datastar.ElementPatchMode.After then
      return "after"
    case datastar.ElementPatchMode.Remove then
      return "remove"
  end
  return "UNKNOWN FragmentMergeMode: " .. fmm
end

local PatchElementsOpts = @record{
  selector: string,
  mode: datastar.ElementPatchMode,
  use_view_transition: boolean,
  event_id: string,
  retry_duration: uinteger
}

function datastar.ServerSentEventGenerator:patch_elements(
  elements: string,
  opts: facultative(PatchElementsOpts)
): string
  local data: sequence(string)
  ## if not opts.type.is_niltype then
    local send_opts: SendOpts = {
      event_id = opts.event_id,
      retry_duration = opts.retry_duration,
    }
    if opts.mode > datastar.ElementPatchMode.not_set then
      data:push(("mode %s"):format(element_patch_mode_text(opts.mode)))
    end
    if opts.selector ~= "" then
      data:push(("selector %s"):format(opts.selector))
    end
    if opts.use_view_transition then
      data:push(("useViewTransition true"))
    end
  ## else
    local send_opts = nil
  ## end
  for line in string.gmatch(elements .. "\n", "([^\r\n]+)\r?\n") do
    data:push(("elements %s"):format(line))
  end

  return send(self, EventType.PatchElements, data, send_opts)
end

function datastar.ServerSentEventGenerator:patch_signals(
  signals: string,
  opts: facultative(record{
    only_if_missing: boolean,
    event_id: string,
    retry_duration: uinteger
  })
): string
  local data: sequence(string)

  ## if not opts.type.is_niltype then
    local send_opts: SendOpts = {
      event_id = opts.event_id,
      retry_duration = opts.retry_duration,
    }
    if opts.only_if_missing then
      data:push(("onlyIfMissing true"))
    end
  ## else
    local send_opts = nil
  ## end

  data:push(("signals %s"):format(signals))

  return send(self, EventType.PatchSignals, data, send_opts)
end

function datastar.ServerSentEventGenerator:execute_script(
  script: string,
  opts: facultative(record{
    auto_remove: boolean,
    attributes: sequence(string),
    event_id: string,
    retry_duration: uinteger
  })
): string

  local sb: stringbuilder
   sb:write("<string")
  ## if not opts.type.is_niltype then
    local patch_el_opts: PatchElementsOpts = {
      event_id = opts.event_id,
      retry_duration = opts.retry_duration,
      selector = "body",
      mode = datastar.ElementPatchMode.Append
    }
    for _, v in ipairs(opts.attributes) do
      sb:writef(" %s", v)
    end
    if opts.auto_remove then
      sb:write(' data-on-load="el.remove()"')
    end
  ## else
    local patch_el_opts = nil
  ## end
  sb:writef(">%s</script>", script)
  local elements = sb:promote()
  return self:patch_elements(elements, patch_el_opts)
end

function datastar.ServerSentEventGenerator:redirect(path: string)
  self:execute_script(('setTimeout(() => window.location = "%s")'):format(path), { auto_remove = true })
end

function datastar.read_signals(server: *http.Server): (json.JsonNode, string)
  if server.req.method == "GET" then
    local signals = server.req.params["datastar"]
    return json.parse_string(signals)
  else
    return json.parse_string(server.req.body)
  end
end

return datastar
