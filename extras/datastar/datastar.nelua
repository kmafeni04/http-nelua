local http = require "...http"
local json = http.json

local datastar = @record{}

local datastar.ServerSentEventGenerator = @record{
  server: *http.Server,
  resp: http.Response
}

local function send_session(self: *http.Server, resp: *http.Response)
  if self.session.send then
    local sb: stringbuilder
    for k, v in pairs(self.session.vals) do
      sb:write(("%s=%s; "):format(k, v))
    end
    sb:rollback(1)
    local session_map = http.utils.b64_encode(sb:promote()) 
    local val = session_map .. "///" .. http.utils.b64_encode(http.utils.sign(self.config.secret, session_map)) 
    resp:set_cookie({
      name = self.config.session_name,
      val = val
    })
    self.session.send = false
  end
end

function datastar.ServerSentEventGenerator.new(server: *http.Server, resp: http.Response): (datastar.ServerSentEventGenerator, string) 
  if server == nilptr then
    return  {}, "Server was a nilptr"
  end

  send_session(server, resp)

  resp.status = 200
  resp.content_type = "text/event-stream"
  local err = resp:set_header("Content-Length", "")
  if err ~= "" then
    return {}, err
  end
  local err = resp:set_header("Cache-Control", "nocache")
  if err ~= "" then
    return {}, err
  end
  local err = resp:set_header("Connection", "keep-alive")
  if err ~= "" then
    return {}, err
  end

  local err = server:write(resp:tostring())
  if err ~= "" then
    return {}, err
  end
  return { server = server, resp = resp }, ""
end

local EventType = @enum{
  MergeFragments = 0,
  MergeSignals,
  RemoveFragments,
  RemoveSignals,
  ExecuteScript,
}

local function event_type_text(e_type: EventType): string
  switch e_type do
    case EventType.MergeFragments then
      return "datastar-merge-fragments"
    case EventType.MergeSignals then
      return "datastar-merge-signals"
    case EventType.RemoveFragments then
      return "datastar-remove-fragments"
    case EventType.RemoveSignals then
      return "datastar-remove-signals"
    case EventType.ExecuteScript then
      return "datastar-execute-script"
  end
  return "UNKNOWN EventType: " .. e_type
end

local SendOpts = @record{
  event_id: string,
  retry_duration: uinteger
}

local function send(
  self: *datastar.ServerSentEventGenerator,
  event: EventType,
  data: sequence(string),
  opts: facultative(SendOpts)
): string
  local sb: stringbuilder

  sb:write(("event: %s\n"):format(event_type_text(event)))
  ## if not opts.type.is_niltype then
    if opts.event_id ~= "" then
      sb:write(("id: %s\n"):format(opts.event_id))
    end
    if opts.retry_duration ~= 0 and opts.retry_duration ~= 1000 then
      sb:write(("retry: %d\n"):format(opts.retry_duration))
    end
  ## end
  for i, v in ipairs(data) do
    sb:write(("data: %s\n"):format(v))
  end
  sb:write("\n")

  local final = sb:promote()
  return self.server:write(final)
end

local datastar.FragmentMergeMode = @enum{
  not_set = 0,
  Morph,
  Inner,
  Outer,
  Prepend,
  Append,
  Before,
  After,
  UpsertAttributes,
}

local function fragment_merge_mode_text(fmm: datastar.FragmentMergeMode): string
  switch fmm do
    case datastar.FragmentMergeMode.Morph then
      return "morph"
    case datastar.FragmentMergeMode.Inner then
      return "inner"
    case datastar.FragmentMergeMode.Outer then
      return "outer"
    case datastar.FragmentMergeMode.Prepend then
      return "prepend"
    case datastar.FragmentMergeMode.Append then
      return "append"
    case datastar.FragmentMergeMode.Before then
      return "before"
    case datastar.FragmentMergeMode.After then
      return "after"
    case datastar.FragmentMergeMode.UpsertAttributes then
      return "upsertAttributes"
  end
  return "UNKNOWN FragmentMergeMode: " .. fmm
end

function datastar.ServerSentEventGenerator:merge_fragments(
  fragments: string,
  opts: facultative(record{
    selector: string,
    merge_mode: datastar.FragmentMergeMode,
    use_view_transition: boolean,
    event_id: string,
    retry_duration: uinteger
  })
): string
  local data: sequence(string)
  ## if not opts.type.is_niltype then
    local send_opts: SendOpts = {
      event_id = opts.event_id,
      retry_duration = opts.retry_duration,
    }
    if opts.selector ~= "" then
      data:push(("selector %s"):format(opts.selector))
    end
    if opts.merge_mode > datastar.FragmentMergeMode.not_set then
      data:push(("mergeMode %s"):format(fragment_merge_mode_text(opts.merge_mode)))
    end
    if opts.use_view_transition then
      data:push(("useViewTransition true"))
    end
  ## else
    local send_opts = nil
  ## end
  for _, line in string.gmatch(fragments .. "\n", "([^\r\n]+)\r?\n") do
    data:push(("fragments %s"):format(line[0]))
  end

  return send(self, EventType.MergeFragments, data, send_opts)
end

function datastar.ServerSentEventGenerator:remove_fragments(
  selector: string,
  opts: facultative(record{
    use_view_transition: boolean,
    event_id: string,
    retry_duration: uinteger
  })
): string
  local data: sequence(string)

  data:push(("selector %s"):format(selector))

  ## if not opts.type.is_niltype then
    local send_opts: SendOpts = {
      event_id = opts.event_id,
      retry_duration = opts.retry_duration,
    }
    if opts.use_view_transition then
      data:push(("useViewTransition true"))
    end
  ## else
    local send_opts = nil
  ## end

  return send(self, EventType.RemoveFragments, data, send_opts)
end

function datastar.ServerSentEventGenerator:merge_signals(
  signals: string,
  opts: facultative(record{
    only_if_missing: boolean,
    event_id: string,
    retry_duration: uinteger
  })
): string
  local data: sequence(string)

  ## if not opts.type.is_niltype then
    local send_opts: SendOpts = {
      event_id = opts.event_id,
      retry_duration = opts.retry_duration,
    }
    if opts.only_if_missing then
      data:push(("onlyIfMissing true"))
    end
  ## else
    local send_opts = nil
  ## end

  data:push(("signals %s"):format(signals))

  return send(self, EventType.MergeSignals, data, send_opts)
end

function datastar.ServerSentEventGenerator:remove_signals(
  paths: sequence(string),
  opts: facultative(record{
    event_id: string,
    retry_duration: uinteger
  })
): string
  local data: sequence(string)

  ## if not opts.type.is_niltype then
    local send_opts: SendOpts = {
      event_id = opts.event_id,
      retry_duration = opts.retry_duration,
    }
  ## else
    local send_opts = nil
  ## end

  for _, v in ipairs(paths) do
    data:push(("paths %s"):format(v))
  end

  return send(self, EventType.RemoveSignals, data, send_opts)
end

function datastar.ServerSentEventGenerator:execute_script(
  script: string,
  opts: facultative(record{
    auto_remove: *boolean,
    attributes: sequence(string),
    event_id: string,
    retry_duration: uinteger
  })
): string
  local data: sequence(string)

  ## if not opts.type.is_niltype then
    local send_opts: SendOpts = {
      event_id = opts.event_id,
      retry_duration = opts.retry_duration,
    }
    if opts.auto_remove ~= nilptr and $opts.auto_remove == false then
      data:push("autoRemove false")
    end
    for _, v in ipairs(opts.attributes) do
      data:push(("attributes %s"):format(v))
    end
  ## else
    local send_opts = nil
  ## end

  data:push(("script %s"):format(script))

  return send(self, EventType.ExecuteScript, data, send_opts)
end

function datastar.ServerSentEventGenerator:redirect(path: string)
  self:execute_script(('setTimeout(() => window.location = "%s")'):format(path))
end

function datastar.read_signals(server: *http.Server): (json.JsonNode, string)
  if server.req.method == "GET" then
    local signals = server.req.params["datastar"]
    return json.parse_string(signals)
  else
    return json.parse_string(server.req.body)
  end
end

return datastar
